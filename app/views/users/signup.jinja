{#<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Inscription</title>
<style>
    body { display: flex; font-family: Arial, sans-serif; }
    .errors-list { width: 30%; padding: 10px; background-color: #fdd; color: #900; margin-right: 20px; }
    .corrected { color: green; }
    .form-container { width: 70%; }
    .field-error { font-size: 0.9em; color: #900; }
    input { width: 100%; padding: 8px; font-size: 1em; border: 2px solid #ccc; border-radius: 4px; }
    input.valid { border-color: green; }
    input.invalid { border-color: red; }
</style>
</head>
<body>

{% if errors %}
<div class="errors-list">
  <h3>Erreurs / Corrections :</h3>
  <ul>
      {% for field, error in errors.items() %}
        <li>{{ error }}</li>
      {% endfor %}

      {% for field in ["username", "email", "password", "confirm_password"] if field not in errors %}
        <li class="corrected">{{ field }} : corrigé</li>
      {% endfor %}
  </ul>
</div>
{% else %}
{% endif %}

<div class="form-container">
  <h1>Inscription</h1>
  <form method="post" action="/users/signup" id="signupForm" novalidate>
      {% af_input %}
    <label for="username">Nom d'utilisateur</label>
    <input type="text" id="username" name="username" autocomplete="off" value="{{ data.username | default('') }}">
    {% if errors.username %}
      <div class="field-error">{{ errors.username }}</div>
    {% endif %}

    <label for="email">Email</label>
    <input type="email" id="email" name="email" autocomplete="off" value="{{ data.email | default('') }}">
    {% if errors.email %}
      <div class="field-error">{{ errors.email }}</div>
    {% endif %}

    <label for="password">Mot de passe</label>
    <input type="password" id="password" name="password">
    {% if errors.password %}
      <div class="field-error">{{ errors.password }}</div>
    {% endif %}

    <label for="confirm_password">Confirmer le mot de passe</label>
    <input type="password" id="confirm_password" name="confirm_password">
    {% if errors.confirm_password %}
      <div class="field-error">{{ errors.confirm_password }}</div>
    {% endif %}

    <button type="submit" style="margin-top: 1em; padding: 10px 20px;">S'inscrire</button>
  </form>
</div>

{% if live_validating %}
<script>
// JavaScript de live validation, minimal et conforme aux règles Python
const form = document.getElementById("signupForm");
const fields = ["username", "email", "password", "confirm_password"];

function validateUsername(value) {
  if (!value) return "Le nom d'utilisateur est obligatoire.";
  if (value.length < 3) return "Le nom d'utilisateur doit contenir au moins 3 caractères.";
  return null;
}

function validateEmail(value) {
  if (!value) return "L'adresse email est obligatoire.";
  const regex = /^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$/;
  if (!regex.test(value)) return "Le format de l'adresse email est invalide.";
  return null;
}

function validatePassword(value) {
  const regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$/;
  if (!regex.test(value)) return "Le mot de passe doit contenir au moins 8 caractères, une majuscule, une minuscule et un chiffre.";
  return null;
}

function validateConfirmPassword(confirmValue, passwordValue) {
  if (confirmValue !== passwordValue) return "La confirmation du mot de passe ne correspond pas.";
  return null;
}

function updateErrors(errors) {
  // Met à jour la liste des erreurs / corrections à gauche et sous les champs
  const errorList = document.querySelector(".errors-list ul");
  errorList.innerHTML = "";

  fields.forEach(field => {
    const input = form[field];
    const errorDiv = document.getElementById("error-" + field);
    if(errors[field]) {
      input.classList.add("invalid");
      input.classList.remove("valid");
      errorDiv.textContent = errors[field];
      const li = document.createElement("li");
      li.textContent = errors[field];
      li.classList.remove("corrected");
      errorList.appendChild(li);
    }
    else {
      input.classList.add("valid");
      input.classList.remove("invalid");
      errorDiv.textContent = "";
      const li = document.createElement("li");
      li.textContent = `${field} : corrigé`;
      li.classList.add("corrected");
      errorList.appendChild(li);
    }
  });
}

function validateForm() {
  const data = {};
  fields.forEach(f => data[f] = form[f].value.trim());
  const errors = {};

  errors.username = validateUsername(data.username);
  errors.email = validateEmail(data.email);
  errors.password = validatePassword(data.password);
  errors.confirm_password = validateConfirmPassword(data.confirm_password, data.password);

  Object.keys(errors).forEach(k => { if (!errors[k]) delete errors[k]; });
  return errors;
}

form.addEventListener("input", () => {
  const errors = validateForm();
  updateErrors(errors);
  form.querySelector("button[type=submit]").disabled = Object.keys(errors).length > 0;
});

document.addEventListener("DOMContentLoaded", () => {
  // Instancie erreurs initiales si valideurs côté serveur ont donné des erreurs
  updateErrors(validateForm());
});
</script>
{% endif %}

</body>
</html>#}
{#
<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Inscription</title>
<style>
    body { display: flex; font-family: Arial, sans-serif; margin: 20px; }
    .errors-list {
        width: 30%;
        padding: 10px;
        background-color: #fdd;
        color: #900;
        margin-right: 20px;
        border-radius: 8px;
    }
    /* ✅ NOUVEAU : Cache la liste par défaut si pas d'erreurs */
    .errors-list.hidden {
        display: none;
    }
    .corrected { color: green; }
    .form-container {
        width: 70%;
    }
    /* ✅ Ajuste la largeur du formulaire quand pas de liste */
    body.no-errors .form-container {
        width: 100%;
    }
    .field-error {
        font-size: 0.9em;
        color: #900;
        margin-top: 4px;
        min-height: 20px;
    }
    .form-group {
        margin-bottom: 15px;
    }
    label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
    }
    input {
        width: 100%;
        padding: 8px;
        font-size: 1em;
        border: 2px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
    }
    input.valid { border-color: green; }
    input.invalid { border-color: red; }
    button {
        margin-top: 1em;
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1em;
    }
    button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
    }
    button:hover:not(:disabled) {
        background-color: #0056b3;
    }
</style>
</head>
<body{% if not errors %} class="no-errors"{% endif %}>

<!-- ✅ La div existe toujours mais est cachée si pas d'erreurs -->
<div class="errors-list{% if not errors %} hidden{% endif %}" id="errorsListContainer">
  <h3>Erreurs / Corrections :</h3>
  <ul id="errorsList">
    {% if errors %}
      {% for field, error in errors.items() %}
        <li>{{ error }}</li>
      {% endfor %}
      {% for field in ["username", "email", "password", "confirm_password"] if field not in errors %}
        <li class="corrected">{{ field }} : corrigé</li>
      {% endfor %}
    {% endif %}
  </ul>
</div>

<div class="form-container">
  <h1>Inscription</h1>
  <form method="post" action="/users/signup" id="signupForm" novalidate>
    {% af_input %}

    <div class="form-group">
      <label for="username">Nom d'utilisateur</label>
      <input type="text" id="username" name="username" autocomplete="off" value="{{ data.username | default('') }}">
      <div class="field-error" id="error-username">
        {% if errors.username %}{{ errors.username }}{% endif %}
      </div>
    </div>

    <div class="form-group">
      <label for="email">Email</label>
      <input type="email" id="email" name="email" autocomplete="off" value="{{ data.email | default('') }}">
      <div class="field-error" id="error-email">
        {% if errors.email %}{{ errors.email }}{% endif %}
      </div>
    </div>

    <div class="form-group">
      <label for="password">Mot de passe</label>
      <input type="password" id="password" name="password">
      <div class="field-error" id="error-password">
        {% if errors.password %}{{ errors.password }}{% endif %}
      </div>
    </div>

    <div class="form-group">
      <label for="confirm_password">Confirmer le mot de passe</label>
      <input type="password" id="confirm_password" name="confirm_password">
      <div class="field-error" id="error-confirm_password">
        {% if errors.confirm_password %}{{ errors.confirm_password }}{% endif %}
      </div>
    </div>

    <button type="submit">S'inscrire</button>
  </form>
</div>

{% if live_validating %}
<script>
// JavaScript de live validation
const form = document.getElementById("signupForm");
const errorsListContainer = document.getElementById("errorsListContainer");
const errorsList = document.getElementById("errorsList");
const fields = ["username", "email", "password", "confirm_password"];

function validateUsername(value) {
  if (!value) return "Le nom d'utilisateur est obligatoire.";
  if (value.length < 3) return "Le nom d'utilisateur doit contenir au moins 3 caractères.";
  return null;
}

function validateEmail(value) {
  if (!value) return "L'adresse email est obligatoire.";
  const regex = /^[\w\.-]+@[\w\.-]+\.\w+$/;
  if (!regex.test(value)) return "Le format de l'adresse email est invalide.";
  return null;
}

function validatePassword(value) {
  if (!value) return "Le mot de passe est obligatoire.";
  const regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/;
  if (!regex.test(value)) {
    return "Le mot de passe doit contenir au moins 8 caractères, une majuscule, une minuscule et un chiffre.";
  }
  return null;
}

function validateConfirmPassword(confirmValue, passwordValue) {
  if (!confirmValue) return "La confirmation du mot de passe est obligatoire.";
  if (confirmValue !== passwordValue) return "La confirmation du mot de passe ne correspond pas.";
  return null;
}

function updateErrors(errors) {
  errorsList.innerHTML = "";

  let hasErrors = false;

  fields.forEach(field => {
    const input = document.getElementById(field);
    const errorDiv = document.getElementById("error-" + field);

    if (errors[field]) {
      hasErrors = true;
      // Mise à jour du champ
      input.classList.add("invalid");
      input.classList.remove("valid");
      errorDiv.textContent = errors[field];

      // Ajout dans la liste à gauche
      const li = document.createElement("li");
      li.textContent = errors[field];
      errorsList.appendChild(li);
    } else {
      // Champ valide
      input.classList.add("valid");
      input.classList.remove("invalid");
      errorDiv.textContent = "";

      // Ajout "corrigé" dans la liste
      const li = document.createElement("li");
      li.textContent = `${field} : corrigé`;
      li.classList.add("corrected");
      errorsList.appendChild(li);
    }
  });

  // ✅ NOUVEAU : Afficher/cacher la liste selon s'il y a des erreurs
  // if (hasErrors) {
  //   errorsListContainer.classList.remove("hidden");
  //   document.body.classList.remove("no-errors");
  // } else {
  //   errorsListContainer.classList.add("hidden");
  //   document.body.classList.add("no-errors");
  // }

  // Désactive le bouton si des erreurs existent
  form.querySelector("button[type=submit]").disabled = hasErrors;
}

function validateForm() {
  const data = {};
  fields.forEach(f => data[f] = form[f].value.trim());

  const errors = {};
  errors.username = validateUsername(data.username);
  errors.email = validateEmail(data.email);
  errors.password = validatePassword(data.password);
  errors.confirm_password = validateConfirmPassword(data.confirm_password, data.password);

  // Supprime les erreurs null
  Object.keys(errors).forEach(k => {
    if (!errors[k]) delete errors[k];
  });

  return errors;
}

// Écoute les changements
form.addEventListener("input", () => {
  const errors = validateForm();
  updateErrors(errors);
});

// Validation initiale au chargement
document.addEventListener("DOMContentLoaded", () => {
  const errors = validateForm();
  updateErrors(errors);
});
</script>
{% endif %}

</body>
</html>#}
{#

<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Inscription</title>
<style>
    body { display: flex; font-family: Arial, sans-serif; margin: 20px; }
    .errors-list {
        width: 30%;
        padding: 10px;
        background-color: #fdd;
        color: #900;
        margin-right: 20px;
        border-radius: 8px;
    }
    .errors-list.hidden {
        display: none;
    }
    .corrected { color: green; }
    .validating { color: #ff9800; }
    .form-container {
        width: 70%;
    }
    body.no-errors .form-container {
        width: 100%;
    }
    .field-error {
        font-size: 0.9em;
        color: #900;
        margin-top: 4px;
        min-height: 20px;
    }
    .form-group {
        margin-bottom: 15px;
    }
    label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
    }
    input {
        width: 100%;
        padding: 8px;
        font-size: 1em;
        border: 2px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
    }
    input.valid { border-color: green; }
    input.invalid { border-color: red; }
    input.validating { border-color: #ff9800; }
    button {
        margin-top: 1em;
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1em;
    }
    button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
    }
    button:hover:not(:disabled) {
        background-color: #0056b3;
    }
    .validation-icon {
        display: inline-block;
        margin-left: 5px;
        font-size: 0.9em;
    }
</style>
</head>
<body{% if not errors %} class="no-errors"{% endif %}>

<!-- Liste d'erreurs dynamique -->
<div class="errors-list{% if not errors %} hidden{% endif %}" id="errorsListContainer">
  <h3>Erreurs / Corrections :</h3>
  <ul id="errorsList">
    {% if errors %}
      {% for field, error in errors.items() %}
        <li>{{ error }}</li>
      {% endfor %}
      {% for field in ["username", "email", "password", "confirm_password"] if field not in errors %}
        <li class="corrected">{{ field }} : corrigé</li>
      {% endfor %}
    {% endif %}
  </ul>
</div>

<div class="form-container">
  <h1>Inscription</h1>
  <form method="post" action="/users/signup" id="signupForm" novalidate>
    {% af_input %}

    <div class="form-group">
      <label for="username">
        Nom d'utilisateur
        <span class="validation-icon" id="username-icon"></span>
      </label>
      <input type="text" id="username" name="username" autocomplete="off" value="{{ data.username | default('') }}">
      <div class="field-error" id="error-username">
        {% if errors.username %}{{ errors.username }}{% endif %}
      </div>
    </div>

    <div class="form-group">
      <label for="email">
        Email
        <span class="validation-icon" id="email-icon"></span>
      </label>
      <input type="email" id="email" name="email" autocomplete="off" value="{{ data.email | default('') }}">
      <div class="field-error" id="error-email">
        {% if errors.email %}{{ errors.email }}{% endif %}
      </div>
    </div>

    <div class="form-group">
      <label for="password">
        Mot de passe
        <span class="validation-icon" id="password-icon"></span>
      </label>
      <input type="password" id="password" name="password">
      <div class="field-error" id="error-password">
        {% if errors.password %}{{ errors.password }}{% endif %}
      </div>
    </div>

    <div class="form-group">
      <label for="confirm_password">
        Confirmer le mot de passe
        <span class="validation-icon" id="confirm_password-icon"></span>
      </label>
      <input type="password" id="confirm_password" name="confirm_password">
      <div class="field-error" id="error-confirm_password">
        {% if errors.confirm_password %}{{ errors.confirm_password }}{% endif %}
      </div>
    </div>

    <button type="submit">S'inscrire</button>
  </form>
</div>

{% if live_validating %}
<script>
// Configuration
const form = document.getElementById("signupForm");
const errorsListContainer = document.getElementById("errorsListContainer");
const errorsList = document.getElementById("errorsList");
const fields = ["username", "email", "password", "confirm_password"];
const url_validate = "/users/signup/validate-field"

// État de validation pour chaque champ
const validationState = {
  username: false,
  email: false,
  password: false,
  confirm_password: false
};

// Debounce timers
const debounceTimers = {};

// ============================================================================
// FONCTION HELPER : Mise à jour de l'interface d'un champ
// ============================================================================
function updateFieldUI(field, message, state) {
  const input = document.getElementById(field);
  const errorDiv = document.getElementById("error-" + field);
  const icon = document.getElementById(field + "-icon");

  input.classList.remove("valid", "invalid", "validating");

  if (state === "validating") {
    // En cours de validation
    input.classList.add("validating");
    errorDiv.textContent = "";
    icon.textContent = "⏳";
    icon.className = "validation-icon validating";

  } else if (state === "valid") {
    // Valide
    input.classList.add("valid");
    errorDiv.textContent = "";
    icon.textContent = "✓";
    icon.className = "validation-icon corrected";

  } else if (state === "invalid") {
    // Invalide
    input.classList.add("invalid");
    errorDiv.textContent = message;
    icon.textContent = "✗";
    icon.className = "validation-icon";
  }
}

// ============================================================================
// VALIDATION USERNAME
// ============================================================================
async function validateUsername(value) {
  const field = "username";

  // 1. Validation côté client (immédiate)
  value = value.trim();

  if (!value) {
    updateFieldUI(field, "Le nom d'utilisateur est obligatoire.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  if (value.length < 3) {
    updateFieldUI(field, "Le nom d'utilisateur doit contenir au moins 3 caractères.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  // 2. Validation AJAX serveur (unicité)
  try {
    updateFieldUI(field, "", "validating");

    const response = await fetch(url_validate, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        field: "username",
        value: value
      })
    });

    const result = await response.json();

    if (result.valid) {
      updateFieldUI(field, "", "valid");
      validationState[field] = true;
      updateErrorsList();
      updateSubmitButton();
      return true;
    } else {
      updateFieldUI(field, result.error, "invalid");
      validationState[field] = false;
      updateErrorsList();
      updateSubmitButton();
      return false;
    }

  } catch (error) {
    console.error("Erreur validation AJAX username:", error);
    updateFieldUI(field, "Erreur de connexion au serveur", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }
}

// ============================================================================
// VALIDATION EMAIL
// ============================================================================
async function validateEmail(value) {
  const field = "email";

  // 1. Validation côté client
  value = value.trim().toLowerCase();

  if (!value) {
    updateFieldUI(field, "L'adresse email est obligatoire.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  // Validation format
  const emailRegex = /^[\w\.-]+@[\w\.-]+\.\w+$/;
  if (!emailRegex.test(value)) {
    updateFieldUI(field, "Le format de l'adresse email est invalide.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  // 2. Validation AJAX serveur (unicité)
  try {
    updateFieldUI(field, "", "validating");

    const response = await fetch(url_validate, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        field: "email",
        value: value
      })
    });

    const result = await response.json();

    if (result.valid) {
      updateFieldUI(field, "", "valid");
      validationState[field] = true;
      updateErrorsList();
      updateSubmitButton();
      return true;
    } else {
      updateFieldUI(field, result.error, "invalid");
      validationState[field] = false;
      updateErrorsList();
      updateSubmitButton();
      return false;
    }

  } catch (error) {
    console.error("Erreur validation AJAX email:", error);
    updateFieldUI(field, "Erreur de connexion au serveur", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }
}

// ============================================================================
// VALIDATION PASSWORD
// ============================================================================
async function validatePassword(value) {
  const field = "password";

  // 1. Validation côté client
  if (!value) {
    updateFieldUI(field, "Le mot de passe est obligatoire.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  // Validation format
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/;
  if (!passwordRegex.test(value)) {
    updateFieldUI(field, "Le mot de passe doit contenir au moins 8 caractères, une majuscule, une minuscule et un chiffre.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  // 2. Validation AJAX serveur (pour cohérence)
  try {
    updateFieldUI(field, "", "validating");

    const response = await fetch(url_validate, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        field: "password",
        value: value
      })
    });

    const result = await response.json();

    if (result.valid) {
      updateFieldUI(field, "", "valid");
      validationState[field] = true;
      updateErrorsList();
      updateSubmitButton();

      // Re-valide confirm_password si déjà rempli
      const confirmInput = document.getElementById("confirm_password");
      if (confirmInput.value) {
        validateConfirmPassword(confirmInput.value);
      }

      return true;
    } else {
      updateFieldUI(field, result.error, "invalid");
      validationState[field] = false;
      updateErrorsList();
      updateSubmitButton();
      return false;
    }

  } catch (error) {
    console.error("Erreur validation AJAX password:", error);
    updateFieldUI(field, "Erreur de connexion au serveur", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }
}

// ============================================================================
// VALIDATION CONFIRM PASSWORD
// ============================================================================
async function validateConfirmPassword(value) {
  const field = "confirm_password";
  const passwordValue = document.getElementById("password").value;

  // 1. Validation côté client
  if (!value) {
    updateFieldUI(field, "La confirmation du mot de passe est obligatoire.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  if (value !== passwordValue) {
    updateFieldUI(field, "La confirmation du mot de passe ne correspond pas.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  // 2. Validation AJAX serveur (pour cohérence)
  try {
    updateFieldUI(field, "", "validating");

    const response = await fetch(url_validate, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        field: "confirm_password",
        value: value,
        password: passwordValue
      })
    });

    const result = await response.json();

    if (result.valid) {
      updateFieldUI(field, "", "valid");
      validationState[field] = true;
      updateErrorsList();
      updateSubmitButton();
      return true;
    } else {
      updateFieldUI(field, result.error, "invalid");
      validationState[field] = false;
      updateErrorsList();
      updateSubmitButton();
      return false;
    }

  } catch (error) {
    console.error("Erreur validation AJAX confirm_password:", error);
    updateFieldUI(field, "Erreur de connexion au serveur", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }
}

// ============================================================================
// MISE À JOUR DE LA LISTE D'ERREURS
// ============================================================================
function updateErrorsList() {
  errorsList.innerHTML = "";
  let hasErrors = false;

  fields.forEach(field => {
    const input = document.getElementById(field);
    const errorDiv = document.getElementById("error-" + field);
    const errorMessage = errorDiv.textContent;

    const li = document.createElement("li");

    if (input.classList.contains("validating")) {
      li.textContent = `${field} : validation en cours...`;
      li.className = "validating";
      errorsList.appendChild(li);

    } else if (errorMessage) {
      hasErrors = true;
      li.textContent = errorMessage;
      errorsList.appendChild(li);

    } else if (validationState[field]) {
      li.textContent = `${field} : corrigé`;
      li.className = "corrected";
      errorsList.appendChild(li);
    }
  });

  // Affiche/cache la liste
  if (hasErrors) {
    errorsListContainer.classList.remove("hidden");
    document.body.classList.remove("no-errors");
  } else {
    errorsListContainer.classList.add("hidden");
    document.body.classList.add("no-errors");
  }
}

// ============================================================================
// MISE À JOUR DU BOUTON DE SOUMISSION
// ============================================================================
function updateSubmitButton() {
  const allValid = fields.every(field => validationState[field] === true);
  const anyValidating = fields.some(field => {
    const input = document.getElementById(field);
    return input.classList.contains("validating");
  });

  form.querySelector("button[type=submit]").disabled = !allValid || anyValidating;
}

// ============================================================================
// DEBOUNCE
// ============================================================================
function debounce(func, delay) {
  return function(field, ...args) {
    clearTimeout(debounceTimers[field]);
    debounceTimers[field] = setTimeout(() => func(...args), delay);
  };
}

// ============================================================================
// ÉCOUTEURS D'ÉVÉNEMENTS
// ============================================================================

// Username
const usernameInput = document.getElementById("username");
const validateUsernameDebounced = debounce((field, value) => validateUsername(value), 500);
usernameInput.addEventListener("input", (e) => {
  validateUsernameDebounced("username", e.target.value);
});

// Email
const emailInput = document.getElementById("email");
const validateEmailDebounced = debounce((field, value) => validateEmail(value), 500);
emailInput.addEventListener("input", (e) => {
  validateEmailDebounced("email", e.target.value);
});

// Password
const passwordInput = document.getElementById("password");
const validatePasswordDebounced = debounce((field, value) => validatePassword(value), 500);
passwordInput.addEventListener("input", (e) => {
  validatePasswordDebounced("password", e.target.value);
});

// Confirm Password
const confirmPasswordInput = document.getElementById("confirm_password");
const validateConfirmPasswordDebounced = debounce((field, value) => validateConfirmPassword(value), 500);
confirmPasswordInput.addEventListener("input", (e) => {
  validateConfirmPasswordDebounced("confirm_password", e.target.value);
});

// ============================================================================
// INITIALISATION
// ============================================================================
document.addEventListener("DOMContentLoaded", () => {
  // Validation initiale si erreurs serveur
  fields.forEach(field => {
    const errorDiv = document.getElementById("error-" + field);
    if (errorDiv.textContent.trim()) {
      updateFieldUI(field, errorDiv.textContent.trim(), "invalid");
      validationState[field] = false;
    }
  });

  updateErrorsList();
  updateSubmitButton();
});
</script>
{% endif %}

</body>
</html>#}



<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Inscription</title>
<style>
    body { display: flex; font-family: Arial, sans-serif; margin: 20px; }
    .errors-list {
        width: 30%;
        padding: 10px;
        background-color: #fdd;
        color: #900;
        margin-right: 20px;
        border-radius: 8px;
    }
    .errors-list.hidden {
        display: none;
    }
    .corrected { color: green; }
    .validating { color: #ff9800; }
    .form-container {
        width: 70%;
    }
    body.no-errors .form-container {
        width: 100%;
    }
    .field-error {
        font-size: 0.9em;
        color: #900;
        margin-top: 4px;
        min-height: 20px;
    }
    .form-group {
        margin-bottom: 15px;
    }
    label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
    }
    input {
        width: 100%;
        padding: 8px;
        font-size: 1em;
        border: 2px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
    }
    input.valid { border-color: green; }
    input.invalid { border-color: red; }
    input.validating { border-color: #ff9800; }
    button {
        margin-top: 1em;
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1em;
    }
    button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
    }
    button:hover:not(:disabled) {
        background-color: #0056b3;
    }
    .validation-icon {
        display: inline-block;
        margin-left: 5px;
        font-size: 0.9em;
    }
</style>
</head>
<body{% if not errors %} class="no-errors"{% endif %}>

<!-- Liste d'erreurs dynamique -->
<div class="errors-list{% if not errors %} hidden{% endif %}" id="errorsListContainer">
  <h3>Erreurs / Corrections :</h3>
  <ul id="errorsList">
    {% if errors %}
      {% for field, error in errors.items() %}
        <li>{{ error }}</li>
      {% endfor %}
      {% for field in ["username", "email", "password", "confirm_password"] if field not in errors %}
        <li class="corrected">{{ field }} : corrigé</li>
      {% endfor %}
    {% endif %}
  </ul>
</div>

<div class="form-container">
  <h1>Inscription</h1>
  <form method="post" action="/users/signup" id="signupForm" novalidate>
    {% af_input %}

    <div class="form-group">
      <label for="username">
        Nom d'utilisateur
        <span class="validation-icon" id="username-icon"></span>
      </label>
      <input type="text" id="username" name="username" autocomplete="off" value="{{ data.username | default('') }}">
      <div class="field-error" id="error-username">
        {% if errors.username %}{{ errors.username }}{% endif %}
      </div>
    </div>

    <div class="form-group">
      <label for="email">
        Email
        <span class="validation-icon" id="email-icon"></span>
      </label>
      <input type="email" id="email" name="email" autocomplete="off" value="{{ data.email | default('') }}">
      <div class="field-error" id="error-email">
        {% if errors.email %}{{ errors.email }}{% endif %}
      </div>
    </div>

    <div class="form-group">
      <label for="password">
        Mot de passe
        <span class="validation-icon" id="password-icon"></span>
      </label>
      <input type="password" id="password" name="password">
      <div class="field-error" id="error-password">
        {% if errors.password %}{{ errors.password }}{% endif %}
      </div>
    </div>

    <div class="form-group">
      <label for="confirm_password">
        Confirmer le mot de passe
        <span class="validation-icon" id="confirm_password-icon"></span>
      </label>
      <input type="password" id="confirm_password" name="confirm_password">
      <div class="field-error" id="error-confirm_password">
        {% if errors.confirm_password %}{{ errors.confirm_password }}{% endif %}
      </div>
    </div>

    <button type="submit">S'inscrire</button>
  </form>
</div>

{% if live_validating %}
<script>
// Configuration
const form = document.getElementById("signupForm");
const errorsListContainer = document.getElementById("errorsListContainer");
const errorsList = document.getElementById("errorsList");
const fields = ["username", "email", "password", "confirm_password"];

// État de validation pour chaque champ
const validationState = {
  username: false,
  email: false,
  password: false,
  confirm_password: false
};

// Debounce timers
const debounceTimers = {};

// ============================================================================
// FONCTION HELPER : Mise à jour de l'interface d'un champ
// ============================================================================
function updateFieldUI(field, message, state) {
  const input = document.getElementById(field);
  const errorDiv = document.getElementById("error-" + field);
  const icon = document.getElementById(field + "-icon");

  input.classList.remove("valid", "invalid", "validating");

  if (state === "validating") {
    // En cours de validation
    input.classList.add("validating");
    errorDiv.textContent = "";
    icon.textContent = "⏳";
    icon.className = "validation-icon validating";

  } else if (state === "valid") {
    // Valide
    input.classList.add("valid");
    errorDiv.textContent = "";
    icon.textContent = "✓";
    icon.className = "validation-icon corrected";

  } else if (state === "invalid") {
    // Invalide
    input.classList.add("invalid");
    errorDiv.textContent = message;
    icon.textContent = "✗";
    icon.className = "validation-icon";
  }
}

// ============================================================================
// VALIDATION USERNAME
// ============================================================================
async function validateUsername(value) {
  const field = "username";

  // 1. Validation côté client (immédiate)
  value = value.trim();

  if (!value) {
    updateFieldUI(field, "Le nom d'utilisateur est obligatoire.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  if (value.length < 3) {
    updateFieldUI(field, "Le nom d'utilisateur doit contenir au moins 3 caractères.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  // 2. Validation AJAX serveur (unicité)
  try {
    updateFieldUI(field, "", "validating");

    const response = await fetch("/users/signup/validate-field", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        field: "username",
        value: value
      })
    });

    const result = await response.json();

    if (result.valid) {
      updateFieldUI(field, "", "valid");
      validationState[field] = true;
      updateErrorsList();
      updateSubmitButton();
      return true;
    } else {
      updateFieldUI(field, result.error, "invalid");
      validationState[field] = false;
      updateErrorsList();
      updateSubmitButton();
      return false;
    }

  } catch (error) {
    console.error("Erreur validation AJAX username:", error);
    updateFieldUI(field, "Erreur de connexion au serveur", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }
}

// ============================================================================
// VALIDATION EMAIL
// ============================================================================
async function validateEmail(value) {
  const field = "email";

  // 1. Validation côté client
  value = value.trim().toLowerCase();

  if (!value) {
    updateFieldUI(field, "L'adresse email est obligatoire.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  // Validation format
  const emailRegex = /^[\w\.-]+@[\w\.-]+\.\w+$/;
  if (!emailRegex.test(value)) {
    updateFieldUI(field, "Le format de l'adresse email est invalide.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  // 2. Validation AJAX serveur (unicité)
  try {
    updateFieldUI(field, "", "validating");

    const response = await fetch("/users/signup/validate-field", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        field: "email",
        value: value
      })
    });

    const result = await response.json();

    if (result.valid) {
      updateFieldUI(field, "", "valid");
      validationState[field] = true;
      updateErrorsList();
      updateSubmitButton();
      return true;
    } else {
      updateFieldUI(field, result.error, "invalid");
      validationState[field] = false;
      updateErrorsList();
      updateSubmitButton();
      return false;
    }

  } catch (error) {
    console.error("Erreur validation AJAX email:", error);
    updateFieldUI(field, "Erreur de connexion au serveur", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }
}

// ============================================================================
// VALIDATION PASSWORD
// ============================================================================
async function validatePassword(value) {
  const field = "password";

  // 1. Validation côté client
  if (!value) {
    updateFieldUI(field, "Le mot de passe est obligatoire.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  // Validation format
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/;
  if (!passwordRegex.test(value)) {
    updateFieldUI(field, "Le mot de passe doit contenir au moins 8 caractères, une majuscule, une minuscule et un chiffre.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  // 2. Validation AJAX serveur (pour cohérence)
  try {
    updateFieldUI(field, "", "validating");

    const response = await fetch("/users/signup/validate-field", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        field: "password",
        value: value
      })
    });

    const result = await response.json();

    if (result.valid) {
      updateFieldUI(field, "", "valid");
      validationState[field] = true;
      updateErrorsList();
      updateSubmitButton();

      // Re-valide confirm_password si déjà rempli
      const confirmInput = document.getElementById("confirm_password");
      if (confirmInput.value) {
        validateConfirmPassword(confirmInput.value);
      }

      return true;
    } else {
      updateFieldUI(field, result.error, "invalid");
      validationState[field] = false;
      updateErrorsList();
      updateSubmitButton();
      return false;
    }

  } catch (error) {
    console.error("Erreur validation AJAX password:", error);
    updateFieldUI(field, "Erreur de connexion au serveur", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }
}

// ============================================================================
// VALIDATION CONFIRM PASSWORD
// ============================================================================
async function validateConfirmPassword(value) {
  const field = "confirm_password";
  const passwordValue = document.getElementById("password").value;

  // 1. Validation côté client
  if (!value) {
    updateFieldUI(field, "La confirmation du mot de passe est obligatoire.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  if (value !== passwordValue) {
    updateFieldUI(field, "La confirmation du mot de passe ne correspond pas.", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }

  // 2. Validation AJAX serveur (pour cohérence)
  try {
    updateFieldUI(field, "", "validating");

    const response = await fetch("/users/signup/validate-field", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        field: "confirm_password",
        value: value,
        password: passwordValue
      })
    });

    const result = await response.json();

    if (result.valid) {
      updateFieldUI(field, "", "valid");
      validationState[field] = true;
      updateErrorsList();
      updateSubmitButton();
      return true;
    } else {
      updateFieldUI(field, result.error, "invalid");
      validationState[field] = false;
      updateErrorsList();
      updateSubmitButton();
      return false;
    }

  } catch (error) {
    console.error("Erreur validation AJAX confirm_password:", error);
    updateFieldUI(field, "Erreur de connexion au serveur", "invalid");
    validationState[field] = false;
    updateErrorsList();
    updateSubmitButton();
    return false;
  }
}

// ============================================================================
// MISE À JOUR DE LA LISTE D'ERREURS
// ============================================================================
function updateErrorsList() {
  errorsList.innerHTML = "";
  let hasErrors = false;

  fields.forEach(field => {
    const input = document.getElementById(field);
    const errorDiv = document.getElementById("error-" + field);
    const errorMessage = errorDiv.textContent;

    const li = document.createElement("li");

    if (input.classList.contains("validating")) {
      li.textContent = `${field} : validation en cours...`;
      li.className = "validating";
      errorsList.appendChild(li);

    } else if (errorMessage) {
      hasErrors = true;
      li.textContent = errorMessage;
      errorsList.appendChild(li);

    } else if (validationState[field]) {
      li.textContent = `${field} : corrigé`;
      li.className = "corrected";
      errorsList.appendChild(li);
    }
  });

  // Affiche/cache la liste
  if (hasErrors) {
    errorsListContainer.classList.remove("hidden");
    document.body.classList.remove("no-errors");
  } else {
    errorsListContainer.classList.add("hidden");
    document.body.classList.add("no-errors");
  }
}

// ============================================================================
// MISE À JOUR DU BOUTON DE SOUMISSION
// ============================================================================
function updateSubmitButton() {
  const allValid = fields.every(field => validationState[field] === true);
  const anyValidating = fields.some(field => {
    const input = document.getElementById(field);
    return input.classList.contains("validating");
  });

  form.querySelector("button[type=submit]").disabled = !allValid || anyValidating;
}

// ============================================================================
// ÉCOUTEURS D'ÉVÉNEMENTS AVEC DEBOUNCE
// ============================================================================

// Username
const usernameInput = document.getElementById("username");
usernameInput.addEventListener("input", (e) => {
  const field = "username";
  const value = e.target.value;

  clearTimeout(debounceTimers[field]);
  debounceTimers[field] = setTimeout(() => {
    validateUsername(value);
  }, 500);
});

// Email
const emailInput = document.getElementById("email");
emailInput.addEventListener("input", (e) => {
  const field = "email";
  const value = e.target.value;

  clearTimeout(debounceTimers[field]);
  debounceTimers[field] = setTimeout(() => {
    validateEmail(value);
  }, 500);
});

// Password
const passwordInput = document.getElementById("password");
passwordInput.addEventListener("input", (e) => {
  const field = "password";
  const value = e.target.value;

  clearTimeout(debounceTimers[field]);
  debounceTimers[field] = setTimeout(() => {
    validatePassword(value);
  }, 500);
});

// Confirm Password
const confirmPasswordInput = document.getElementById("confirm_password");
confirmPasswordInput.addEventListener("input", (e) => {
  const field = "confirm_password";
  const value = e.target.value;

  clearTimeout(debounceTimers[field]);
  debounceTimers[field] = setTimeout(() => {
    validateConfirmPassword(value);
  }, 500);
});

// ============================================================================
// INITIALISATION
// ============================================================================
document.addEventListener("DOMContentLoaded", () => {
  // Validation initiale si erreurs serveur
  fields.forEach(field => {
    const errorDiv = document.getElementById("error-" + field);
    if (errorDiv.textContent.trim()) {
      updateFieldUI(field, errorDiv.textContent.trim(), "invalid");
      validationState[field] = false;
    }
  });

  updateErrorsList();
  updateSubmitButton();
});
</script>
{% endif %}

</body>
</html>
